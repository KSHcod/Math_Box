<커밋에 관한 주의사항>
1. 처음으로 커밋을 하기 전 사용자의 이름과 이메일 주소를 설정
= git config user.name "이름"
= git config user.email "이메일 주소"

2. 커밋 메시지 남기기(옵션 -m)
= git commit -m "메시지"

3. 커밋할 파일을 git add 로 지정
= git add  "파일명"

<git add와 관련해 꼭 알아야할 사실 하나>

Git은 내부적으로 크게 3가지 종류의 작업 영역을 두고 동작합니다.

각 작업 영역의 이름은

1. working directory
2. staging area
3. repository

입니다. 순서대로 하나씩 설명해드릴게요.

1. 첫 번째 작업 영역인 working directory는 작업을 하는 프로젝트 디렉토리를 말합니다. 그러니까 지금 상황에서는 MathTool 디렉토리가 working directory입니다.

2. 두 번째 작업 영역인 staging area는 git add를 한 파일들이 존재하는 영역입니다. 커밋을 하게되면 staging area에 있는 파일들만 커밋에 반영됩니다.

3. 세 번째 작업 영역인 repository는 working directory의 변경 이력들이 저장되어 있는 영역입니다. 그러니까 커밋들이 저장되는 영역이라는 뜻인데요. 조금 풀어서 설명해볼게요.

working directory에서 뭔가 작업을 하고,
작업한 파일들을 git add 해주고,
커밋을 하면 staging area에 있던 파일들의 모습이 마치 영화의 한 장면, 스냅샷(snapshot)처럼 이 repository에 저장되는 겁니다.

그리고 '02. repository 만들기' 영상에서 본 것처럼 실제로는 MathTool 디렉토리 안에 숨겨져 있던 .git 디렉토리가 repository입니다.

이전 그림에서 작업을 좀더 하고 나서의 모습인데요. 다음과 같은 작업을 추가적으로 했습니다.

1. working directory에서 A.txt 파일 내용에 Python~이라는 단어를 추가, B.txt 파일 내용에 Morning!이라는 단어를 추가했습니다. 
2. 그런데 이번에는 git add B.txt만 실행해서 B.txt 파일만 staging area에 올렸습니다. 
3. 그 다음 git commit -m "Ver_2"로 두 번째 커밋을 했습니다. 

이전 그림과 다른 점은 A.txt는 staging area에 올리지 않고, B.txt만 staging area에 올렸다는 점입니다. 그랬더니 지금 repository에서 그 결과가 어떤가요? Ver_2 커밋을 보면 지금

1. A.txt는 staging area에 있던 모습, 그러니까 수정하기 이전의 모습이 Ver_2 커밋에 반영되었고
2. B.txt도 staging area에 있던 모습, 하지만 A.txt와는 달리 수정한 이후의 모습이 Ver_2 커밋에 반영되었습니다.

A.txt, B.txt 둘다 working directory에서 수정했다는 사실은 같지만, staging area에 올렸는지 여부에 따라 그 최신 모습이 커밋에 반영되는지가 달라지는 겁니다. 바로 이 점이 Git을 사용할 때 잘 알고 기억해야하는 부분입니다.

그런데 staging area가 굳이 왜 필요할까요? working directory에서 작업을 하고 git add할 필요없이 바로 커밋해버리는 구조가 더 편할 것 같은데 말이죠. 하지만 꼭 그렇지는 않습니다. 방금처럼 A.txt와 B.txt 파일을 둘다 수정했더라도 두 파일 모두 그 최신 모습을 다음 커밋에 반영하고 싶지 않을 수도 있습니다. 방금처럼 B.txt의 최신 모습만 그 다음 커밋에 반영하고 싶을 수도 있는 거죠. 이런 상황은 실제로 꽤 자주 있습니다. 만약 staging area가 없다면 원하는 것들만 선별적으로 커밋에 반영할 수 없게 됩니다. 그럼 좀더 세밀한 버전 관리를 할 수 없게 되는 거죠. 왜 staging area가 필요한지 알겠죠?

<수정 파일 전부 반영하기>
= git add .

<git에서의 파일 상태>

이전 노트에서 Git의 3가지 작업 영역을 배웠습니다. 

작업 영역과 관련해서 한 가지 더 알아두면 좋은 내용이 있는데요.

그건 바로 Git으로 관리되는 파일은 일종의 '상태(status)'라는 걸 가진다는 사실입니다. 

일단 Git에서 파일들은 크게 다음 2가지 상태를 가집니다.

Untracked 상태
Tracked 상태 
그리고 Tracked 상태는 다시 아래와 같은 3가지 상태로 나눌 수 있구요. 

Staged 상태
Unmodified 상태
Modified 상태
각 상태를 순서대로 설명해드릴게요.

1. Untracked 상태

Untracked는 '추적되지 않고 있는'이라는 뜻입니다. 이 상태는 파일이 Git에 의해서 그 변동사항이 전혀 추적되고 있지 않는 상태를 뜻합니다. 예를 들어, 파일을 새로 생성하고 그 파일을 한 번도 git add 해주지 않았다면 이 상태입니다.

2. Tracked 상태

파일이 Git에 의해 그 변동사항이 추적되고 있는 상태입니다. 이 상태는 다시 그 특성에 따라 3가지 상태로 나뉩니다. 하나씩 설명할게요.

(1) Staged 상태

파일의 내용이 수정되고나서, staging area에 올라와있는 상태를 Staged(스테이징된, stage area에 올려진) 상태라고 합니다.

새로 생성한 파일에 내용을 쓰고 git add를 해주거나
한 번이라도 커밋에 포함됐었던 파일이라도 내용을 수정하고 git add를 해주면 이 상태입니다.
(2) Unmodified 상태

현재 파일의 내용이 최신 커밋의 모습과 비교했을 때 전혀 바뀐 게 없는 상태면 그 파일은 Unmodified(수정되지 않은, 변한 게 없는) 상태입니다. 커밋을 하고 난 직후에는 working directory 안의 모든 파일들이 이 상태가 됩니다.

(3) Modified 상태

최신 커밋의 모습과 비교했을 때 조금이라도 바뀐 내용이 있는 상태면 그 파일은 Modified(수정된) 상태입니다.

이렇게 Git에서 파일은 매 순간 4가지 상태 중 하나의 상태에 있게 됩니다. 이 내용을 그림으로 정리하면 아래와 같습니다.

<staged 된 파일을 되돌릴 때>
= git reset "파일명"
이후에는 워킹 해당 파일은 워킹 디렉토리(트리)에서는 수정된 상태 Modified 일 것이다.
워킹 디렉토리의 해당 파일에서 다시 추가했던 내용을 삭제하고 git status 확인하면
nothing commit, working tree clean 이라는 메시지가 나올 것

<새롭게 커맨드를 배울 때 그 의미나 사용법을 자세히 알려면>
= git help [알고싶은 커맨드 이름] or man git-[알고 싶은 커맨드]
이 공식 매뉴얼 화면에서 나가려면 quit의 줄임말 q를 누르면 됨

<git push>

로컬 레포지토리(Local Repository)의 최신 내용을 리모트 레포지토리(Remote Repository)에도 반영하려면

git push를 해야함

그렇다면 아무나 git push라고만 쓰면 자신이 작업한 내용을 저의 리모트 레포지토리에 반영할 수 있는 걸까요?

그건 아닙니다. 

이게 만약 가능하다면 저도 모르는 사이에 제 리모트 레포지토리의 내용이 맘대로 바뀌어 버릴 수도 있겠죠? 사실 git push는 리모트 레포지토리의 주인, 그러니까 본인만 할 수 있습니다. 만약 본인이 아닌 다른 사용자도 git push를 할 수 있게 하려면 GitHub에서 추가 작업을 해줘야 합니다.

GitHub에는 훌륭한 프로젝트들이 많습니다. 그리고 이런 프로젝트는 대부분 그 소스 코드가 공개되어 있습니다. 이렇게 소스 코드가 공개되어 있는 프로젝트를 '오픈 소스 프로젝트(open source project)'라고 하는데요. ‘오픈 소스’가 뭘까요? 간단히 설명하자면 프로그램의 소스 코드가 대중에 공개된 상태일 때 오픈 소스라고 합니다. 오픈 소스라는 용어의 의미는 그것이 생겨난 역사적 배경을 살펴보면 좀더 잘 이해할 수 있습니다.  

아주 오래 전에 프로그램이라고 하는 건 그 소스 코드를 공개하고, 공유하고, 그 원리를 아는 사람이 모르는 사람에게 가르쳐주는 게 당연한 존재였습니다. 하지만 컴퓨터 프로그램 시장이 발전하면서 특정 회사가 어떤 프로그램을 만들고 그 사용료 등을 받는 것이 일반화되기 시작했는데요. 이런 변화와 함께 프로그램의 소스 코드들은 점점 그 프로그램을 만든 회사만 갖고 있고 공개되지 않기 시작했습니다. 그러니까 내가 고객으로서 어떤 회사의 프로그램을 쓰더라도 그 프로그램의 소스 코드를 볼 수는 없게 된 겁니다.

하지만 이런 움직임에 반해 1983년 ‘리차드 스톨만(Richard Stallman)’이라고 하는 MIT의 연구원이 '자유 소프트웨어 운동'이라는 걸 시작했습니다. 아주 오래 전 소스 코드를 공유하던 문화로 돌아가자는 취지의 운동이었는데요. 그는 곧이어 '자유 소프트웨어 재단(Free Software Foundation)' 이라는 걸 세우고 이러한 운동을 조직화했습니다. 자유 소프트웨어 재단에서 소프트웨어는

- 그 소스 코드가 공개되어야 하고

- 누구나 코드를 자유롭게 가져다가 사용할 수 있고

- 원래의 코드를 자신이 원하는 대로 수정할 수 있어야한다 

는 정신이 강조되었고, 그러한 정신에 부합하는 프로그램들이 그 운동 속에서 많이 만들어졌습니다. 그 중 대표적인 프로그램은 바로 'GNU 리눅스'라고 하는 운영체제입니다. GNU 리눅스에 대한 이야기는 실용적 유닉스 커맨드 토픽의 유닉스 운영 체제 레슨을 참고하세요.

그런데 이런 자유 소프트웨어(Free Software)라는 명칭에 대해서는 그 의미가 확실하지 않다는 몇몇 논란이 있었고, 이러한 성격의 소프트웨어를 가리키기 위한 다른 용어로 ‘오픈 소스 소프트웨어’가 제시되었습니다.(자유 소프트웨어와 오픈 소스 소프트웨어가 조금은 다르다고 보는 의견도 있지만 여기서는 일단 같다고 보겠습니다.)

이런 역사적 흐름을 거쳐 오픈 소스 소프트웨어라는 개념이 생기고 정착하게 된 것인데요.

요즘 여러분이 들어봤을 수도 있는 유명한 오픈 소스 소프트웨어에는

- numpy(이전 영상에서 살펴본 파이썬 수치 계산용 라이브러리, https://github.com/numpy/numpy)

- Linux(위에서 말한 리눅스, https://github.com/torvalds/linux)

- MySQL Server(데이터베이스 프로그램, https://github.com/mysql/mysql-server)

- WordPress(설치형 블로그 프로그램, https://github.com/WordPress/WordPress)

- React Native(페이스북에서 만든 모바일 UI 프레임워크, https://github.com/facebook/react-native)

- Vue.js(웹 UI 프레임워크, https://github.com/vuejs/vue)

- Tensorflow(머신러닝 프레임워크, https://github.com/tensorflow/tensorflow )

등이 있습니다. 많은 유명 프로그램들이 사실은 이런 오픈 소스 프로젝트로 개발되고 있는 경우가 꽤 많습니다.

하지만 오픈 소스라고 해서 사용할 때 항상 아무런 제약이 없는 것은 아닙니다. 왜냐하면 사실 오픈 소스에도 다양한 종류의 라이센스(open source license)들이 있기 때문입니다. 예를 들어 어떤 오픈 소스 라이센스 중에는

- 오픈 소스가 활용된 부분이 있는 코드라면 그 코드도 마찬가지로 오픈 소스로 공개해야 한다.

- 기존의 오픈 소스 내용 중 조금 수정해서 사용한 부분이 있다면 그것을 표시하고 써야 한다.

같은 제약이 있는 것들도 있습니다. 사실 오픈 소스 라이센스의 종류와 그 특징은 그 자체로 하나의 토픽이 될 정도로 많은 내용이 있기 때문에 궁금하신 분들은 이 링크를 참조하세요.

그럼 오픈 소스 프로젝트는 어떤 장점이 있을까요? 아래와 같은 장점이 있습니다.

- 무료로 사용할 수 있다.

- 여러 개발자들이 참여하기 때문에 폐쇄적으로 코드를 관리할 때보다 코드의 신뢰도가 더 높다.(이 부분은 사람마다 의견이 다를 수 있습니다)

- 오픈 소스 프로젝트에 참여 중인 다른 개발자들에게 질문을 할 수 있다.

- 어떤 프로그램을 개발할 때 특정 분야에서 사실상 표준처럼 사용되는 오픈 소스 프로그램을 많이 활용할수록 전체 개발 속도를 단축시킬 수 있다.

반면에 단점은

- 참여자 수가 많지 않거나, 참여자의 실력이 좋지 않으면 소스 코드의 신뢰성을 보장하기 어렵다. 

- 해당 오픈 소스를 사용해서 문제가 생겼을 때 보상을 해주거나, 책임을 질 주체가 없다.

등이 있습니다. 오픈 소스라고 무조건 좋은 것은 아니기 때문에 충분히 공신력 있는 오픈 소스 프로젝트인지를 따져보고 사용하는 게 좋습니다.

GitHub는 이러한 오픈 소스 프로젝트들이 많이 있는 사이트입니다. 여기서 어느 정도 공신력이 있는 오픈 소스 프로젝트의 경우에는 Facebook이나 Google같은 세계적인 IT 회사의, 실력있는 개발자들이 만든 코드를 자유롭게 살펴볼 수 있고 공부할 수 있습니다. 그래서 사실 개발자들에게 GitHub만큼 좋은 공부 장소가 없습니다. 자신이 관심있는 분야의 오픈 소스 프로젝트의 코드를 분석하거나, 좀더 나아가 오픈 소스 수정에 기여할 수 있다면 그 중에 이루어지는 성장은 대단할 겁니다. 이런 흔적은 GitHub의 본인 계정 정보에도 다 표시되기 때문에 그 자체로도 개발자에게는 훌륭한 이력이 됩니다. 

이번 토픽을 통해 Git과 GitHub를 사용하는 법에 능숙해지고난 후에는 GitHub의 오픈 소스에 기여하는 방법도 따로 배워보시면 좋을 것 같네요!